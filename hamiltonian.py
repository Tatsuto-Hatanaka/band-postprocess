from numpy import *
from scipy.stats import norm
from time import time
import os

class hamiltonian:
  def __init__(self, p):
    time_b = time()

    if p.ispin==1 or p.ispin==3:
      self.hr = self.read_tb(p, p.prefix+'_tb.dat')

    elif p.ispin==2:
      self.hr_up = self.read_tb(p, p.prefix+'_tb.up.dat')
      self.hr_dn = self.read_tb(p, p.prefix+'_tb.dn.dat')
      self.hr = kron(self.hr_up, array([[1,0],[0,0]])) + kron(self.hr_dn, array([[0,0],[0,1]]))
      self.nwan *= 2

    with open(p.std_file, "a") as f:
      f.write("    TIME(READ_TB) : {0}\n".format(time()-time_b))

  def read_tb(self, p, filename):
    """ Read tight-binding model data from SEEDNAME_tb.dat file (generated by Wannier90)

      Args:
          p (class):
                instance of "parameters" class
          filename (str):
                name of tb-file (formatted with SEEDNAME_tb.dat)

      Variants:
          lattice_r (np.array, shape:(3,3)):
                primitive lattice vectors in real-space (cartesian [Ang] unit)
          lattice_k (np.array, shape:(3,3)):
                primitive lattice vectors in reciprocal-space (cartesian [2pi/Ang] unit)
          nwan (int):
                number of wannier functions
          nrpt (int):
                number of lattice points where hopping terms in the TB-model are calculated
          cdeg (float):
                inverse of the degree of degeneracy
          rvec (np.array, shape:(nrpt,3)):
                rvec[i][i1,i2,i3], R_i = ni1 a1 + ni2 a2 + ni3 a3
          hr (np.array, shape:(nrp,nwan,nwan)):
                hamiltonian of the system in real-space, H_lm(R_i) =  <w_l(0)|H|w_m(R_i)>  (eV)

    """
    with open(filename, 'r') as f:
        contents = f.readlines()
        f.close()

    self.lattice_r = fromstring(''.join(contents[1:4]), sep='\n').reshape((3,3))
    self.lattice_k = transpose(linalg.inv(self.lattice_r))
    self.nwan      = int(contents[4].strip())
    self.nrp       = int(contents[5].strip())
    ndeg_line = self.nrp // 15
    if self.nrp % 15 != 0: ndeg_line += 1
    self.cdeg  = fromstring(''.join(contents[6: 6+ndeg_line]), sep='\n')
    self.cdeg  = 1.0/self.cdeg
    self.rvec  = fromstring(''.join(contents[7+ndeg_line:7+ndeg_line+(2+self.nwan**2)*self.nrp:(2+self.nwan**2)]), sep='\n').reshape((self.nrp,3))
    assert(len(self.rvec)==self.nrp)

    contents_hr = contents[6+ndeg_line:7+ndeg_line+(2+self.nwan**2)*self.nrp]
    del contents_hr[:(2+self.nwan**2)*self.nrp:2+self.nwan**2]
    del contents_hr[:(1+self.nwan**2)*self.nrp:1+self.nwan**2]
    hr = fromstring(''.join(contents_hr), sep='\n').reshape(self.nrp,self.nwan,self.nwan,4)
    hr = transpose(hr[:,:,:,2]+1j*hr[:,:,:,3], axes=(0,2,1))
    return hr

  def calc_band(self, p, filename):
    time_b = time()
    if p.codes=='VASP':
      from kpath import kpath
      kpath, kpline = kpath()

    phase = exp(2j*pi*einsum('ik,jk->ij', kpath, self.rvec))
    fact  = einsum('ij,j->ij', phase, self.cdeg)
    hk    = einsum('ij,jkl->ikl', fact, self.hr)

    ek, uk = linalg.eigh(hk)
    ek = ek - p.fermi*ones((len(kpath),self.nwan))

    if p.ispin==2:
      self.plot_band(p, filename+"_up.dat", kpline, ek[:,::2], uk[:,::2,::2])
      self.plot_band(p, filename+"_up.dat", kpline, ek[:,1::2], uk[:,1::2,1::2])
    else:
      self.plot_band(p, filename+".dat", kpline, ek, uk)

    with open(p.std_file, "a") as f:
      f.write("    TIME(BAND_PLOT) : {0}\n".format(time()-time_b))


  def plot_band(self, p, filename, kpline, ek, uk):
    with open(p.out_dir+"/"+filename,"w") as file:
      for i in range(len(ek[0])):
        for j in range(len(ek)):
          file.write("{0:10.6f}  {1:10.6f}  ".format(kpline[j], ek[j][i]))
          if p.band_decompose:
            weight = abs(uk[j,:,i])**2
            for i in range(p.n_orbital_type):
              file.write("{0:10.6f}  ".format(sum(weight[array(p.orbital_decompose)==i])))
            file.write("\n")
        file.write("\n")
      file.close()


  def r_to_k(self, p):
    """ Fourier transform from r-space to k-space

    Args:
        hk (np.array, shape:(nkp,nwan,nwan)):
              hamiltonian in reciprocal-space, hk[i,l,m], H_lm(k_i) = sum_j exp(1j*k_i.R_j) H_lm(R_j)

    """
    time_b = time()
    phase, nkp = exp(2j*pi*(self.rvec@p.kpoints).T) * self.cdeg, p.kpoints.shape[1]
    hr = self.hr.reshape(self.nrp, self.nwan**2)
    hk = phase@hr
    self.hk = hk.reshape(nkp,self.nwan,self.nwan)
    with open(p.std_file, "a") as f:
      f.write("    TIME(R_TO_K) : {0}\n".format(time()-time_b))


  def diagonalization(self, p):
    """ Diagonalizing Hamiltonian
      Note that uk is defined such that U^\dagger H_w U = H_b is a diagonal matrix.
    """
    time_b = time()
    self.ek0, self.uk = linalg.eigh(self.hk)
    self.uk_dagger = conjugate(transpose(self.uk, (0,2,1)))
    self.ek = self.ek0 - p.fermi*ones((len(self.hk),self.nwan))
    self.fermi_dist = 0.5*(1.0-tanh(0.5*p.beta*self.ek))
    with open(p.std_file, "a") as f:
      f.write("    TIME(DIAGONAL) : {0}\n".format(time()-time_b))


  def dehybridization(self, p):
    for icomb, combs in enumerate(p.orbitals_dehybrid):
       for i1, idx1 in enumerate(combs[0]):
         for i2, idx2 in enumerate(combs[1]):
           norb1  = p.orbitals[idx1]
           norb2  = p.orbitals[idx2]
           start1 = sum(p.orbitals[:idx1])
           start2 = sum(p.orbitals[:idx2])
           if p.ispin==2:
             norb1  *= 2
             norb2  *= 2
             start1 *= 2
             start2 *= 2
           self.hk[start1:start1+norb1,start2:start2+norb2] = 0
           self.hk[start2:start2+norb2,start1:start1+norb1] = 0


  def calc_pdos(self,p,filename):
    time_b = time()
    pdos = zeros((len(p.pdos_e_range), self.nwan))
    nkp = p.kpoints.shape[1]
    for ie,e in enumerate(p.pdos_e_range):
      for i in range(self.nwan):
        u2         = abs(self.uk[:,i,:])**2
        delta      = norm.pdf(e*ones((nkp,self.nwan))-self.ek, 0, p.smearing)
        pdos[ie,i]   = sum(u2*delta)/nkp

    if p.ispin==2:
      self.plot_pdos(p, filename+"_up.dat", pdos[:,::2])
      self.plot_pdos(p, filename+"_dn.dat", pdos[:,1::2])
    else:
      self.plot_pdos(p, filename+".dat", pdos)

    with open(p.std_file, "a") as f:
      f.write("    TIME(PDOS) : {0}\n".format(time()-time_b))

  def plot_pdos(self, p, filename, pdos):
    pdos_all        = pdos.sum(axis=1)
    pdos_all_cumsum = pdos.sum(axis=1).cumsum()
    pdos_per_orbtype = []
    pdos_per_orbtype_cumsum = []
    for i in range(p.n_orbital_type):
      pdos_ = sum(pdos[:,array(p.orbital_decompose)==i], axis=1)
      pdos_per_orbtype.append(pdos_)
      pdos_per_orbtype_cumsum.append(cumsum(pdos_))
    if p.orbital_each_pdos:
      pdos_per_eachorb = []
      pdos_per_eachorb_cumsum = []
      for orbtype in p.orbital_each_pdos:
        for i in range(sum(array(p.orbital_decompose)==orbtype)):
          pdos_ = pdos[:,array(p.orbital_decompose)==orbtype][:,i]
          pdos_per_eachorb.append(pdos_)
          pdos_per_eachorb_cumsum.append(cumsum(pdos_))
    with open(p.out_dir+"/"+filename,"w") as file:
      for ie,e in enumerate(p.pdos_e_range):
        file.write("{0:14.6f} ".format(e))
        file.write("{0:14.6f} ".format(pdos_all[ie]))
        file.write("{0:14.6f} ".format(pdos_all_cumsum[ie]))
        for i in range(p.n_orbital_type):
          file.write("{0:14.6f} ".format(pdos_per_orbtype[i][ie]))
          file.write("{0:14.6f} ".format(pdos_per_orbtype_cumsum[i][ie]))
        if p.orbital_each_pdos:
          for i in range(len(pdos_per_eachorb)):
            file.write("{0:14.6f} ".format(pdos_per_eachorb[i][ie]))
            file.write("{0:14.6f} ".format(pdos_per_eachorb_cumsum[i][ie]))